#include "utils_h.fos"
#include "worldmap_h.fos"
#include "npc_planes_h.fos"
#include "entire.fos"
#include "_colors.fos"
#include "quest_killmobs_h.fos"
#include "messages_h.fos"
#include "npc_common_h.fos"
#include "npc_planes_h.fos"
#include "utils_h.fos"
#include "logging_h.fos"

/*Rinzler:
  -Changes-
*Defined array of fixed co-ordinates where Pomona spawns, east of LA. 
*Gave mobs fixed dialog ID and fixed EXP values.
*Stripped NPC resists so that they are restricted to armor and perks, rather than innate resists given them in the past.
*Re-designed map.
*Added 2 magic lockers, using same table as Vertibird event. 
*Created new lockers in spawner container for the rest of the loot. 
*/
 
#define QUEST_FAILED                (0)  //value of quest lvar in case of quest failed

#define ROLE_DEFAULT      (0)
#define ROLE_AGRESSIVE    (1)

#define IDLE_NORMAL       (5000)
#define IDLE_ALERTED      (1000)

#define NPC_HUMAN_COUNT             (Random(45, 60))

array<uint> npcHumanPids = { 590, 591, 567, 568, 569, 570, 571, 546, 547, 548 };
array<uint> npcHumanBags = { 194, 192, 192, 195, 199, 203, 392, 396, 201, 390 }; 

//function called as request from dialog to spawn quest location
void r_SpawnLoc(Critter& player, Critter@ npc)
{// removed randomly generated coords because, fuck that.
    array<array<uint>> spawnCoords = {
        {1813, 2264}, 
        {1777, 2230},  
        {1759, 2286}, 
        {1761, 2297}, 
        {1723, 2240}, 
        {1869, 2263}   
    };

    uint index = Random(0, spawnCoords.length() - 1);
    uint wx = spawnCoords[index][0]; // X coordinate
    uint wy = spawnCoords[index][1]; // Y coordinate
	
    //version with defined set of maps, comment this one and uncomment lines about to use zone maps
    array<uint16> locationIds = { 254 };
    uint num = locationIds.length;
 
    //pick random encounter map
    uint16        locPid = locationIds[Random(0, num - 1)];
   
    //create quest location
    Critter@[] crits = { player };
    int           loc = CreateLocation(locPid, wx, wy, crits);
    if(loc == 0)
        return;
    player.SetKnownLoc(true, loc);
     
    //change location color on WM
    Location@ location = GetLocation(loc);
    location.Color = COLOR_WM_QUEST;
    location.Update();
	

 
    //set location id to quest lvar (used when you need to delete location)
    GameVar@  locidv = GetLocalVar(LVAR_z_ladungeonspncity_locid, player.Id);
    locidv = loc;

	//player can die and come back
    location.AutoGarbage = false;

    array<Map@> maps;
    uint        mapcount = location.GetMaps(maps);
    for(uint c = 0; c < mapcount; c++)
    {
        array<Entire> entires;
        ParseEntires(maps[c], entires, 666);

        uint cntNpc = NPC_HUMAN_COUNT;
        uint npcHumanPidCount = npcHumanPids.length()-1;

        for(uint i = 0; i < cntNpc; i++)
        {
            if (entires.length() == 0)
                ParseEntires(maps[c], entires, 666);

            uint entId = Random(0, entires.length()-1);
            Entire@ ent = entires[entId];
            entires.removeAt(entId);

            uint16 pos = Random(0, npcHumanPidCount);   
            uint16 npcPid = npcHumanPids[pos];
            int[] params =
            {
                ST_REPLICATION_TIME, REPLICATION_NEVER,
                ST_NPC_ROLE, 1,
				ST_DIALOG_ID, 84,
                ST_TEAM_ID, 5001,
                ST_BAG_ID, npcHumanBags[pos],           
                ST_LEVEL, Random(5, 40),
				ST_KILL_EXPERIENCE, 1500
				
					
				
            };
     
            Critter@ npc = maps[c].AddNpc(npcPid , ent.HexX, ent.HexY, Random(0, 5), params, null, "_MobNPC");
        }
    }
	
	
	//12 hour decay
	SetQuestGarbager(1 * 60, player.Id, loc, LVAR_z_ladungeoncity, QUEST_FAILED);
    DynamicLocationAddLog(player, npc, locidv, "la dungeon city");
}

 
//dialog function used in request to delete quest location (after player report finishing the quest)
void r_DeleteLoc(Critter& player, Critter@ npc)
{
    GameVar@ var = GetLocalVar(LVAR_z_ladungeonspncity_locid, player.Id);
    DeleteLocation(var.GetValue());
    DynamicLocationDelLog(player, npc, var, "la dungeon city");
}

void _MobNPC(Critter& mob, bool firstTime)
{
    _CritSetExtMode(mob, MODE_EXT_MOB);
    _CritSetMode(mob, MODE_NO_DROP);
	mob.StatBase[ST_NORMAL_ABSORB] = 0;
	mob.StatBase[ST_LASER_ABSORB] = 0;
	mob.StatBase[ST_PLASMA_ABSORB] = 0;
	mob.StatBase[ST_FIRE_ABSORB] = 0;
	mob.StatBase[ST_ELECTRO_ABSORB] = 0;
	mob.StatBase[ST_EXPLODE_ABSORB] = 0;
	mob.StatBase[ST_NORMAL_RESIST] = 0;
	mob.StatBase[ST_LASER_RESIST] = 0;
	mob.StatBase[ST_PLASMA_RESIST] = 0;
	mob.StatBase[ST_FIRE_RESIST] = 0;
	mob.StatBase[ST_ELECTRO_RESIST] = 0;
	mob.StatBase[ST_EXPLODE_RESIST] = 0;
	mob.ModeBase[MODE_NO_HOME] = 0;
    mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;
    mob.SetEvent(CRITTER_EVENT_IDLE, "_MobIdle");
    mob.SetEvent(CRITTER_EVENT_ATTACKED, "_MobAttacked");
    mob.SetEvent(CRITTER_EVENT_ATTACK, "_MobAttacking");
    mob.SetEvent(CRITTER_EVENT_MESSAGE, "_MobOnMessage");
    mob.SetEvent(CRITTER_EVENT_SMTH_DEAD, "_MobSmthDead");
	if(firstTime)
    {
        RandomizePerks(mob);
    }
}

void RandomizePerks(Critter& mob)
{
    mob.PerkBase[PE_BONUS_RATE_OF_FIRE] = 1;
    mob.PerkBase[PE_SHARPSHOOTER] = 1;
    for(uint i = 0, j = Random(0, 2); i < j; i++)
        mob.PerkBase[PE_BONUS_RANGED_DAMAGE] = 1;
    mob.PerkBase[PE_BETTER_CRITICALS] = 1;
    if(Random(0, 49) == 0)
        mob.PerkBase[PE_SNIPER] = 1;
    if(Random(0, 20) == 0)
        mob.PerkBase[PE_MAN_OF_STEEL] = 1;
    if(Random(0, 1) == 0)
        mob.PerkBase[PE_STONEWALL] = 1;
	if(Random(0, 10) == 0)
        mob.PerkBase[PE_ACTION_BOY] = 1;

    for(uint i = 0, j = Random(1, 3); i < j; i++)
        mob.PerkBase[PE_MORE_CRITICALS] += 1;
    for(uint i = 0, j = Random(1, 2); i < j; i++)
        mob.PerkBase[PE_TOUGHNESS] = 1;
    if(Random(0, 5) == 0)
        mob.PerkBase[PE_ADRENALINE_RUSH] = 1;
	if(Random(0, 10) == 0)
        mob.PerkBase[PE_MORE_RANGED_DAMAGE] = 1;
	for(uint i = 0, j = Random(1, 2); i < j; i++)
        mob.PerkBase[PE_EVEN_TOUGHER] = 1;
}

void _MobIdle(Critter& mob)
{
    if(!mob.IsLife())
    {
        mob.Wait(IDLE_NORMAL);
        return;
    }

    array<Critter@> crits;
    uint            num = mob.GetCritters(false, FIND_ONLY_PLAYERS | FIND_LIFE, crits);
    uint dist = GetDistance(mob);
    for(uint i = 0; i < num; i++)
    {
        uint curDist = GetCrittersDistantion(mob, crits[i]);
        if(curDist > dist)
        {
            continue;
        }
        else
        {
            if(crits[i].Mode[MODE_HIDE] != 0 || curDist < 5)
            {
                AttackCritter(mob, crits[i]);
            }
            else
            {
                mob.AddEnemyInStack(crits[i].Id);
            }
            return;
        }
    }

    if(crits.length() > 0)
    {
        mob.Wait(IDLE_ALERTED);
    }
    else
    {
        if(Random(0, 5) == 0)
            mob.MoveRandom();
        mob.Wait(IDLE_NORMAL);
    }
}

uint GetDistance(Critter& cr)
{
    uint base = __LookNormal + 3 * cr.Stat[ST_PERCEPTION];

    if(cr.Stat[ST_NPC_ROLE] == ROLE_AGRESSIVE)
        return base / 2;
    else
        return base / 3;
}

bool _MobAttacked(Critter& cr, Critter& attacker)
{
    cr.SendMessage(MSG_IM_ATTACKED, attacker.Id, MESSAGE_TO_WHO_SEES_ME);
    return false;
}

bool _MobAttacking(Critter& cr, Critter& attacker)
{
    cr.SendMessage(MSG_GUARD_ATTACKING, attacker.Id, MESSAGE_TO_WHO_SEES_ME);
    return false;
}

void _MobOnMessage(Critter& cr, Critter& fromCr, int message, int value)
{
    if(message == MSG_IM_ATTACKED || message == MSG_GUARD_ATTACKING)
    {
        uint dist = GetDistance(cr);
        if(GetCrittersDistantion(cr, fromCr) <= dist/2)
            AttackCritter(cr, GetCritter(value));
    }        
}

void _MobSmthDead(Critter& cr, Critter& killed, Critter@ killer)
{
    cr.EraseEnemyFromStack(killed.Id);
}
 
 
