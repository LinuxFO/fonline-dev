//
// FOnline: 2238
// Rotators
//
// talchem.fos
/* -Rinzler-

*Updated to make Talchem a viable dungeon. 
*There are 2 entrances to talchem lvl 1, both of which lead to exclusive parts of it. The stairs in the main building go down to the airlock and main area which leads to level 2. Some robots to fight and a few
 lockers contain chems and drug craft materials. The manhole at the top of map leads to the other half of level 1, again there are a few lockers and robots and two other areas where groups of aliens quarantined
 behind blast doors. These doors can released with successful science check on terminal and players can fight the aliens to get to lockers behind, one of which is low spawning magic locker. The aliens have the ability to
 poison on hit.
*Level 2 is a large area with more robots and several patches of toxic sludge spillage which will poison the player on crossing, players can bring rubber boots to nullify this (none spawn at talchem). There is a 
 normal spawning magic locker at the end of this floor and an escape later back to the surface. 
*/

#include "_animation.fos"
#include "_macros.fos"
#include "_maps.fos"
#include "_npc_pids.fos"
#include "mob.fos"
#include "MsgStr.h"


import bool LockerOpen(Item& item) from "lockers";
import bool LockerClose(Item& item) from "lockers";
import void SwitchState(Item& locker) from "lockers";
import void InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId) from "combat";
import void AffectRadiation(Critter& cr, int value) from "radiation";
import void AffectPoison(Critter& cr, int value) from "poison";



void map_init(Map& map, bool firstTime)
{
    if (firstTime)
    {
        array<Item@> doors;
        for (uint i = 0, j = map.GetItemsByType(ITEM_TYPE_DOOR, doors); i < j; i++)
        {
            if (doors[i].Val6 == 0)
            {
                doors[i].Val7 = 9999999;
                doors[i].Val6 = 9999999;
            }
        }
    }
    // Radiation loop
    map.SetEvent(MAP_EVENT_LOOP_0, "_Radiate");
    map.SetLoopTime(0, 10000);
}


//Radiate all critters on map except Black Rock Soldiers
void _Radiate(Map& map)
{
    array<Critter@> crits;
    uint num = map.GetCritters(0, FIND_ALL, crits);
    
    for (uint i = 0; i < crits.length(); i++)
    {
        if (crits[i].GetProtoId() != 2019)  // Exclude PID 2019
        {
            AffectRadiation(crits[i], Random(50, 100));
        }
    }
}

void ondoor1(Item& item, bool firstTime)
{
	
	item.SetEvent(ITEM_EVENT_SKILL, "_UseDoor1");
	
}

void ondoor2(Item& item, bool firstTime)
{
	
	item.SetEvent(ITEM_EVENT_SKILL, "_UseDoor2");
	
}

bool _UseDoor1(Item& item, Critter& player, int skill)
{
	// Opening / Closing
	player.Animate(ANIM1_UNARMED, ANIM2_USE, item, true, true);
	
    if((skill == -1) || (skill == SK_LOCKPICK))
    {	
		Map@ map = GetMap(item.MapId);
		Item@ Door1=map.GetItem(178, 211, 25428);
		array<uint> door1data = { Door1.Id, map.Id };
		
		if(FLAG(Door1.LockerCondition, LOCKER_ISOPEN))
		{
			player.Say(SAY_NETMSG, "The door is stuck.");
		}
        else
            {
		       player.Say(SAY_NETMSG, "The door is locked, it would appear to be an electronic lock");
			}
		
        return true;
    }
	return false;
}

bool _UseDoor2(Item& item, Critter& player, int skill)
{
	// Opening / Closing
	player.Animate(ANIM1_UNARMED, ANIM2_USE, item, true, true);
	
    if((skill == -1) || (skill == SK_LOCKPICK))
    {	
		Map@ map = GetMap(item.MapId);
		Item@ Door2=map.GetItem(228, 211, 25428);
		array<uint> door2data = { Door2.Id, map.Id };
		
		if(FLAG(Door2.LockerCondition, LOCKER_ISOPEN))
		{
			player.Say(SAY_NETMSG, "The door is stuck.");
		}
        else
            {
		       player.Say(SAY_NETMSG, "The door is locked, it would appear to be an electronic lock");
			}
		
        return true;
    }
	return false;
}

bool s_Door1(Critter& player, Scenery& terminal, int skill, Item@ item)
{
    if (!player.IsPlayer() || skill != SK_SCIENCE)
    {   
        player.Say(SAY_NETMSG, "It might need a more scientific approach.");
        return true;
    }

    Map@ map = player.GetMap();
    if (!valid(map)) return false;

    Item@ Door1 = null;

    switch (map.GetProtoId())
    {
        case MAP_Talchem_lvl1:
            @Door1 = map.GetItem(178, 211, 25428);
            break;
        default:
            return false;
    }

    array<uint> Door1data = { Door1.Id, map.Id };
    uint value = player.Skill[SK_SCIENCE] - Random(5, 15);

    if (value > 60)
    {
        if (!FLAG(Door1.LockerCondition, LOCKER_ISOPEN))
        {
            CreateTimeEvent(AFTER(REAL_MINUTE(30)), "CloseDoor1", Door1data, true);
            SwitchState(Door1);
            player.Say(SAY_NETMSG, "The doors open");
            return true;
        }
        player.Say(SAY_NETMSG, "The doors are already open.");
        return true;  // Door is already open, successful hack
    }
    
    player.Say(SAY_NETMSG, "You've failed to hack the security system.");
    return true; 
}


uint CloseDoor1(array<uint>@ values)
{
	Item@ Door1 = GetItem(values[0]);
	Map@ map = GetMap(values[1]);	
	
    if(!valid(Door1))
        return 0;
		
	if(FLAG(Door1.LockerCondition, LOCKER_ISOPEN))
	{
		SwitchState(Door1);
		
	}	
	return 0;
}

bool s_Door2(Critter& player, Scenery& terminal, int skill, Item@ item)
{
    if (!player.IsPlayer() || skill != SK_SCIENCE)
    {   
        player.Say(SAY_NETMSG, "It might need a more scientific approach.");
        return true;
    }

    Map@ map = player.GetMap();
    if (!valid(map)) return false;

    Item@ Door2 = null;

    switch (map.GetProtoId())
    {
        case MAP_Talchem_lvl1:
            @Door2 = map.GetItem(228, 211, 25428); // Adjust the coordinates and ID accordingly
            break;
        default:
            return false;
    }

    array<uint> Door2data = { Door2.Id, map.Id };
    uint value = player.Skill[SK_SCIENCE] - Random(5, 15);

    if (value > 60)
    {
        if (!FLAG(Door2.LockerCondition, LOCKER_ISOPEN))
        {
            CreateTimeEvent(AFTER(REAL_MINUTE(30)), "CloseDoor2", Door2data, true);
            SwitchState(Door2);
            player.Say(SAY_NETMSG, "The doors open");
            return true;
        }
        player.Say(SAY_NETMSG, "The doors are already open.");
        return true;  // Door is already open, successful hack
    }

    player.Say(SAY_NETMSG, "You've failed to hack the security system.");
    return true; 
}


uint CloseDoor2(array<uint>@ values)
{
	Item@ Door2 = GetItem(values[0]);
	Map@ map = GetMap(values[1]);	
	
    if(!valid(Door2))
        return 0;
		
	if(FLAG(Door2.LockerCondition, LOCKER_ISOPEN))
	{
		SwitchState(Door2);
		
	}	
	return 0;
}

bool IsImmune(Critter& cr)
{
  return (cr.Stat[ST_BODY_TYPE] == BT_ROBOT || cr.Stat[ST_BODY_TYPE] == BT_ALIEN);
}


bool IsRubberBoots(Critter& cr)
{
    return valid(cr.GetItem(PID_RUBBER_BOOTS, -1));
}


void ToxicSludge(Critter& cr, Scenery& trigger, bool entered, uint8 Dir) 
{
    if (IsRubberBoots(cr)) 
    {
        if (Random(1, 100) == 1)
        {
            cr.DeleteItem(PID_RUBBER_BOOTS, 1);
            cr.Say(SAY_NETMSG, "Your boots dissolved in the sludge.");
        }
    }
    else 
    {
        if (cr.IsLife() && !IsImmune(cr))
        {
            InjureCritter(cr, Random(40, 60), DAMAGE_NORMAL, cr.Dir, 0);
            AffectPoison(cr, Random(15, 30));
			Map@ map = cr.GetMap();
            
           
            
        }
    }
}


void _Alien(Critter& mob, bool firstTime)
{    
    critter_init_aggr(mob, firstTime); 
	mob.StatBase[ST_NPC_ROLE] = 1;  
	mob.StatBase[ST_TEAM_ID] = 5001; 
    mob.StatBase[ST_KILL_EXPERIENCE] = 500; 
    mob.StatBase[ST_REPLICATION_TIME] = 900;
    mob.StatBase[ST_TOXIC] = 10;
    mob.ModeBase[MODE_NO_HOME] = 0;
    mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;	
}

void _Robot(Critter& mob, bool firstTime)
{    
    critter_init(mob, firstTime); 
	mob.StatBase[ST_NPC_ROLE] = 1;  
	mob.StatBase[ST_TEAM_ID] = 5002; 
    mob.StatBase[ST_KILL_EXPERIENCE] = 500; 
    mob.StatBase[ST_REPLICATION_TIME] = 900;
    mob.PerkBase[PE_BONUS_RANGED_DAMAGE] = 1;
    mob.ModeBase[MODE_NO_HOME] = 0;
    mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;	
}

void _Robot2(Critter& mob, bool firstTime)
{    
    critter_init(mob, firstTime); 
	//mob.StatBase[ST_NPC_ROLE] = 1;  
	mob.StatBase[ST_TEAM_ID] = 5002; 
    mob.StatBase[ST_KILL_EXPERIENCE] = 500; 
    mob.StatBase[ST_REPLICATION_TIME] = 900;
    mob.PerkBase[PE_BONUS_RANGED_DAMAGE] = 1;
    mob.ModeBase[MODE_NO_HOME] = 0;
    mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;	
}


uint innerGateEntire            = 10; // entire pod vnitrni branou
uint outerLeftGateEntire        = 11; // entire pod vnejsi levou branou
uint outerRightGateEntire       = 12; // entire pod vnejsi pravou branou
uint innerLeftGateEntire        = 13; // entire pod vnejsi levou branou
uint innerRightGateEntire       = 14; // entire pod vnejsi pravou branou

// pripichnout k Acku
bool s_InnerTerminalA(Critter& player, Scenery& terminal, int skill, Item@ item)
{
    return s_TerminalAirlock(player, terminal, skill, item, 1);
}

// pripichnout k Bcku
bool s_MiddleTerminalB(Critter& player, Scenery& terminal, int skill, Item@ item)
{
    return s_TerminalAirlock(player, terminal, skill, item, 2);
}

// pripichnout k Ccku
bool s_OuterTerminalC(Critter& player, Scenery& terminal, int skill, Item@ item)
{
    return s_TerminalAirlock(player, terminal, skill, item, 3);
}

bool s_TerminalAirlock(Critter& player, Scenery& terminal, int skill, Item@ item, int whichTerm)
{
    if(player.IsPlayer() && skill == -1 && !valid(item))
    {
        Map @ map = player.GetMap();
        uint16 x = 0, y = 0;

        map.GetEntireCoords(innerGateEntire, 0, x, y);
        Item@ innerDoor = map.GetDoor(x, y);

        map.GetEntireCoords(outerLeftGateEntire, 0, x, y);
        Item@ outerLeftDoor = map.GetDoor(x, y);


        map.GetEntireCoords(outerRightGateEntire, 0, x, y);
        Item@ outerRightDoor = map.GetDoor(x, y);
		
		map.GetEntireCoords(innerLeftGateEntire, 0, x, y);
        Item@ innerLeftDoor = map.GetDoor(x, y);


        map.GetEntireCoords(innerRightGateEntire, 0, x, y);
        Item@ innerRightDoor = map.GetDoor(x, y);

        if(whichTerm == 1)
        {
            bool closeOuter = false;
			bool closeInside = false;
            if(valid(innerDoor))
            {
                closeInside = !FLAG(innerDoor.LockerCondition, LOCKER_ISOPEN);
                if(closeInside)
                    innerDoor.LockerOpen();
                else
                    innerDoor.LockerClose();
            }
			if(valid(innerRightDoor))
            {
                if(closeInside)
                    innerRightDoor.LockerClose();
                else
                    innerRightDoor.LockerOpen();
            }
            if(valid(innerLeftDoor))
            {
                if(closeInside)
                    innerLeftDoor.LockerClose();
                else
                    innerLeftDoor.LockerOpen();
            }
			if(valid(outerRightDoor))
            {
                if(closeOuter)
                    outerRightDoor.LockerOpen();
                else
                    outerRightDoor.LockerClose();
            }
            if(valid(outerLeftDoor))
            {
                if(closeOuter)
                    outerLeftDoor.LockerOpen();
                else
                    outerLeftDoor.LockerClose();
            }
			
        }
        if(whichTerm == 2)
        {
		    bool closeInside = false;
            bool closeOuter = false;
            if(valid(innerDoor))
            {
                closeOuter = !FLAG(innerDoor.LockerCondition, LOCKER_ISOPEN);
                if(closeOuter)
                    innerDoor.LockerOpen();
                else
                    innerDoor.LockerClose();
            }
            if(valid(outerRightDoor))
            {
                if(closeOuter)
                    outerRightDoor.LockerClose();
                else
                    outerRightDoor.LockerOpen();
            }
            if(valid(outerLeftDoor))
            {
                if(closeOuter)
                    outerLeftDoor.LockerClose();
                else
                    outerLeftDoor.LockerOpen();
            }
			if(valid(innerRightDoor))
            {
                if(closeInside)
                    innerRightDoor.LockerOpen();
                else
                    innerRightDoor.LockerClose();
            }
            if(valid(innerLeftDoor))
            {
                if(closeInside)
                    innerLeftDoor.LockerOpen();
                else
                    innerLeftDoor.LockerClose();
            }
			
			
        }
        
        if(whichTerm == 3)
        {
            
			bool closeOuter = false;
            if(valid(innerDoor))
            {
                closeOuter = !FLAG(innerDoor.LockerCondition, LOCKER_ISOPEN);
                if(closeOuter)
                    innerDoor.LockerOpen();
                else
                    innerDoor.LockerClose();
            }
            if(valid(outerRightDoor))
            {
                if(closeOuter)
                    outerRightDoor.LockerClose();
                else
                    outerRightDoor.LockerOpen();
            }
            if(valid(outerLeftDoor))
            {
                if(closeOuter)
                    outerLeftDoor.LockerClose();
                else
                    outerLeftDoor.LockerOpen();
            }
			
        }
        
        return true;
    }
    return false;
}

bool s_TerminalDial(Critter& player, Scenery& terminal, int skill, Item@ item, int dialNum)
{
    if(player.IsPlayer() && skill == -1 && !valid(item))
        RunDialog(player, dialNum, terminal.HexX, terminal.HexY, false);
    return true;
}







































//Unused Legacy

const uint32 doorCloseInterval = 5;                                       // za jak dlouho se to ma zavrit -v sekundach
const uint32 chanceToJam = 20;                                            // sance na zaseknuti po zavreni dveri -v procentech
const uint32 criticalFailChance = 5;                                      // sance na fail opravy i s uspesnym checkem -v procentech
const uint32 repairCheckBottom = 80;                                      // dolni hranice skillu pri hodu na opravy
const uint32 repairCheckTop = 150;                                        // horni hranice skillu pri hodu na opravy
string       jammedMessage = "The door is jammed... electronically.";     // dvere jsou zasekly!
string       doorOkMessage = "The door is working fine... for now.";      // oprava jiz opravenych dveri
string       repairFailMessage = "You didn't manage to repair the door."; // oprava se nepovedla
string       repairCritFailMessage = "You almost had it.";                // oprava se mela povyst ale kvuli kritickymu neuspechu se nezdarila
string       repairSuccessMessage = "You successfully repair the door.";  // oprava se povedla




void _AutoDoorInit(Item& door, bool firstTime)                            // pripichnout ke dverim
{
    door.SetEvent(ITEM_EVENT_SKILL, "_AutoDoorOpen");
}

bool _AutoDoorOpen(Item& item, Critter& crit, int skill)
{
    if(skill == -1)
    {
        bool isOpen = FLAG(item.LockerCondition, LOCKER_ISOPEN);
        if(item.Val1 != 0 && !isOpen)
        {
            crit.Say(SAY_NETMSG, jammedMessage);
            return true;
        }
        array<uint> vals(2);
        vals[0] = item.Id;
        vals[1] = item.MapId;

        if(isOpen)
        {
            uint16 hexX = 0;
            uint16 hexY = 0;
            Map@   map = item.GetMapPosition(hexX, hexY);
            if(valid(map))
            {
                Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
                if(valid(potentialBlocker) && potentialBlocker.IsLife())
                    return false;
            }
        }

        if(item.Val0 != 0)
            EraseTimeEvent(item.Val0);
        if(!isOpen)
            item.Val0 = CreateTimeEvent(__FullSecond + REAL_SECOND(doorCloseInterval), "e_AutoCloseDoor", vals, false);
        else
        {
            tryJamDoor(item);
        }
    }
    else if(skill == SK_REPAIR)
    {
        if(item.Val1 == 0)
            crit.Say(SAY_NETMSG, doorOkMessage);
        else
        {
            if(crit.Timeout[TO_SK_REPAIR] > 0)
            {
                crit.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS);
                return true;
            }

            if(Random(repairCheckBottom, repairCheckTop) <= crit.Param[SK_REPAIR])
            {
                if(Random(1, 100) > criticalFailChance)
                {
                    item.Val1 = 0;
                    crit.Say(SAY_NETMSG, repairSuccessMessage);
                }
                else
                    crit.Say(SAY_NETMSG, repairCritFailMessage);
            }
            else
                crit.Say(SAY_NETMSG, repairFailMessage);

            crit.TimeoutBase[TO_SK_REPAIR] = REPAIR_TIMEOUT(crit);
        }
        return true;
    }

    return false;
}

uint e_AutoCloseDoor(array<uint>@ vals)
{
    Map@ map = GetMap(vals[1]);
    if(valid(map))
    {
        Item@ door = map.GetItem(vals[0]);
        if(valid(door))
        {
            uint16   hexX = 0;
            uint16   hexY = 0;
            door.GetMapPosition(hexX, hexY);
            Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
            if(valid(potentialBlocker) && potentialBlocker.IsLife())
                return REAL_SECOND(doorCloseInterval);

            door.LockerClose();
            door.Val0 = 0;
            tryJamDoor(door);
        }
    }
    return 0;
}

void tryJamDoor(Item@ door)
{
    if(Random(1, 100) <= chanceToJam)
    {
        door.Val1 = 1;
    }
}





const uint32 doorCloseInterval2 = 5;             // za jak dlouho se to ma zavrit -v sekundach
const uint32 chanceToJam2 = 25;                  // sance na zaseknuti po zavreni dveri -v procentech
const uint32 hackVarId  = 9210;                  // id promenne
const uint32 dialogId   = 22120;                 // id dialogu
void _HackDoorInit(Item& door, bool firstTime)   // pripichnout ke dverim
{
    door.SetEvent(ITEM_EVENT_SKILL, "_HackDoorOpen");
}

bool _HackDoorOpen(Item& item, Critter& crit, int skill)
{
    if(skill == -1)
    {
        bool isOpen = FLAG(item.LockerCondition, LOCKER_ISOPEN);

        if(isOpen)
        {
            uint16 hexX = 0;
            uint16 hexY = 0;
            Map@   map = item.GetMapPosition(hexX, hexY);
            if(valid(map))
            {
                Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
                if(valid(potentialBlocker) && potentialBlocker.IsLife())
                    return false;
            }
        }

        if(isOpen)
        {
            if(item.Val0 != 0)
                EraseTimeEvent(item.Val0);
            tryJamHackDoor();
        }
    }
    return false;
}

uint e_HackCloseDoor(array<uint>@ vals)
{
    Map@ map = GetMap(vals[1]);
    if(valid(map))
    {
        Item@ door = map.GetItem(vals[0]);
        if(valid(door))
        {
            uint16   hexX = 0;
            uint16   hexY = 0;
            door.GetMapPosition(hexX, hexY);
            Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
            if(valid(potentialBlocker) && potentialBlocker.IsLife())
                return REAL_SECOND(doorCloseInterval2);

            door.LockerClose();
            door.Val0 = 0;
            tryJamHackDoor();
        }
    }
    return 0;
}

void tryJamHackDoor()
{
    if(Random(1, 100) <= chanceToJam2)
    {
        GameVar@ hackVar = GetGlobalVar(hackVarId);
        hackVar = 1;
    }
}

bool s_HackDoorOpen(Critter& player, Scenery& terminal, int skill, Item@ item)   // pripichnout k terminalu //ParamCount = 0
{
    if(player.IsPlayer() && skill == -1 && !valid(item))
    {
        RunDialog(player, dialogId, terminal.HexX, terminal.HexY, true);
        return true;
    }
    return false;
}

void r_HackDoorOpen(Critter& player, Critter@ victim, int entireNum)   // todle je do toho dialogu //ParamCount = 1, Param0 = entire pod dverma
{
    uint16 hexX = 0;
    uint16 hexY = 0;
    Map@   map = player.GetMap();
    map.GetEntireCoords(entireNum, 0, hexX, hexY);
    Item@  door = map.GetDoor(hexX, hexY);
    door.LockerOpen();

    array<uint> vals(2);
    vals[0] = door.Id;
    vals[1] = door.MapId;
    if(door.Val0 != 0)
        EraseTimeEvent(door.Val0);
    door.Val0 = CreateTimeEvent(__FullSecond + REAL_SECOND(doorCloseInterval2), "e_HackCloseDoor", vals, false);
}

const uint32 doorCloseInterval3 = 5;                                        // za jak dlouho se to ma zavrit -v sekundach
const uint32 chanceToJam3 = 20;                                             // sance na zaseknuti po zavreni dveri -v procentech
const uint32 criticalFailChance3 = 5;                                       // sance na fail lockpicku i s uspesnym checkem -v procentech
const uint32 lockpickCheckBottom = 100;                                     // dolni hranice skillu pri hodu na lockpick
const uint32 lockpickCheckTop = 150;                                        // horni hranice skillu pri hodu na lockpick
string       jammedMessage3 = "The door is locked.";                        // dvere jsou zamceny
string       doorOkMessage3 = "The door isn't locked.";                     // odemceni jiz odemcenych dveri
string       lockpickFailMessage = "You didn't manage to unlock the door."; // lockpick fail
string       lockpickCritFailMessage = "You almost had it.";                // oprava se mela povyst ale kvuli kritickymu neuspechu se nezdarila
string       lockpickSuccessMessage = "You successfully unlock the door.";  // oprava se povedla

void _AutoDoorInit3(Item& door, bool firstTime)                             // pripichnout ke dverim
{
    door.SetEvent(ITEM_EVENT_SKILL, "_AutoDoorOpen3");
}

bool _AutoDoorOpen3(Item& item, Critter& crit, int skill)
{
    if(skill == -1)
    {
        bool isOpen = FLAG(item.LockerCondition, LOCKER_ISOPEN);
        if(item.Val1 != 0 && !isOpen)
        {
            crit.Say(SAY_NETMSG, jammedMessage3);
            return true;
        }
        array<uint> vals(2);
        vals[0] = item.Id;
        vals[1] = item.MapId;

        if(isOpen)
        {
            uint16 hexX = 0;
            uint16 hexY = 0;
            Map@   map = item.GetMapPosition(hexX, hexY);
            if(valid(map))
            {
                Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
                if(valid(potentialBlocker) && potentialBlocker.IsLife())
                    return false;
            }
        }

        if(item.Val0 != 0)
            EraseTimeEvent(item.Val0);
        if(!isOpen)
            item.Val0 = CreateTimeEvent(__FullSecond + REAL_SECOND(doorCloseInterval3), "e_AutoCloseDoor3", vals, false);
        else
        {
            tryJamDoor3(item);
        }
    }
    else if(skill == SK_LOCKPICK)
    {
        if(item.Val1 == 0)
            crit.Say(SAY_NETMSG, doorOkMessage3);
        else
        {
            if(crit.Timeout[TO_SK_LOCKPICK] > 0)
            {
                crit.SayMsg(SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS);
                return true;
            }

            if(Random(lockpickCheckBottom, lockpickCheckTop) <= crit.Param[SK_LOCKPICK])
            {
                if(Random(1, 100) > criticalFailChance3)
                {
                    item.Val1 = 0;
                    crit.Say(SAY_NETMSG, lockpickSuccessMessage);
                }
                else
                    crit.Say(SAY_NETMSG, lockpickCritFailMessage);
            }
            else
                crit.Say(SAY_NETMSG, lockpickFailMessage);

            crit.TimeoutBase[TO_SK_LOCKPICK] = LOCKPICK_TIMEOUT(crit);
        }
        return true;
    }

    return false;
}

uint e_AutoCloseDoor3(array<uint>@ vals)
{
    Map@ map = GetMap(vals[1]);
    if(valid(map))
    {
        Item@ door = map.GetItem(vals[0]);
        if(valid(door))
        {
            uint16   hexX = 0;
            uint16   hexY = 0;
            door.GetMapPosition(hexX, hexY);
            Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
            if(valid(potentialBlocker) && potentialBlocker.IsLife())
                return REAL_SECOND(doorCloseInterval3);

            door.LockerClose();
            door.Val0 = 0;
            tryJamDoor3(door);
        }
    }
    return 0;
}

void tryJamDoor3(Item@ door)
{
    if(Random(1, 100) <= chanceToJam3)
    {
        door.Val1 = 1;
    }
}

const uint32 doorCloseInterval4 = 5;              // za jak dlouho se to ma zavrit -v sekundach
const uint32 chanceToJam4 = 25;                   // sance na zaseknuti po zavreni dveri -v procentech
const uint32 hackVarId1 = 9211;                   // id promenne
const uint32 dialogId1  = 22121;                  // id dialogu
void _HackDoorInit1(Item& door, bool firstTime)   // pripichnout ke dverim
{
    door.SetEvent(ITEM_EVENT_SKILL, "_HackDoorOpen");
}

bool _HackDoorOpen1(Item& item, Critter& crit, int skill)
{
    if(skill == -1)
    {
        bool isOpen = FLAG(item.LockerCondition, LOCKER_ISOPEN);

        if(isOpen)
        {
            uint16 hexX = 0;
            uint16 hexY = 0;
            Map@   map = item.GetMapPosition(hexX, hexY);
            if(valid(map))
            {
                Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
                if(valid(potentialBlocker) && potentialBlocker.IsLife())
                    return false;
            }
        }

        if(isOpen)
        {
            if(item.Val0 != 0)
                EraseTimeEvent(item.Val0);
            tryJamHackDoor1();
        }
    }
    return false;
}

uint e_HackCloseDoor1(array<uint>@ vals)
{
    Map@ map = GetMap(vals[1]);
    if(valid(map))
    {
        Item@ door = map.GetItem(vals[0]);
        if(valid(door))
        {
            uint16   hexX = 0;
            uint16   hexY = 0;
            door.GetMapPosition(hexX, hexY);
            Critter@ potentialBlocker = map.GetCritter(hexX, hexY);
            if(valid(potentialBlocker) && potentialBlocker.IsLife())
                return REAL_SECOND(doorCloseInterval4);

            door.LockerClose();
            door.Val0 = 0;
            tryJamHackDoor1();
        }
    }
    return 0;
}

void tryJamHackDoor1()
{
    if(Random(1, 100) <= chanceToJam4)
    {
        GameVar@ hackVar = GetGlobalVar(hackVarId1);
        hackVar = 1;
    }
}

bool s_HackDoorOpen1(Critter& player, Scenery& terminal, int skill, Item@ item)   // pripichnout k terminalu //ParamCount = 0
{
    if(player.IsPlayer() && skill == -1 && !valid(item))
    {
        RunDialog(player, dialogId1, terminal.HexX, terminal.HexY, true);
        return true;
    }
    return false;
}

void r_HackDoorOpen1(Critter& player, Critter@ victim, int entireNum)   // todle je do toho dialogu //ParamCount = 1, Param0 = entire pod dverma
{
    uint16 hexX = 0;
    uint16 hexY = 0;
    Map@   map = player.GetMap();
    map.GetEntireCoords(entireNum, 0, hexX, hexY);
    Item@  door = map.GetDoor(hexX, hexY);
    door.LockerOpen();

    array<uint> vals(2);
    vals[0] = door.Id;
    vals[1] = door.MapId;
    if(door.Val0 != 0)
        EraseTimeEvent(door.Val0);
    door.Val0 = CreateTimeEvent(__FullSecond + REAL_SECOND(doorCloseInterval4), "e_HackCloseDoor1", vals, false);
}
