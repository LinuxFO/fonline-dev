/*
   FOnline: 2258
   Rinzler

   map_black_rock.fos

   **Black Rock Dungeon Event**
   
   *Black Rock is opened using the item PID_ACCESS_CARD (140)
   *Loot will spawn inside the lockers each time the dungeon is opened and at no other time. 
   *The map is radiated but an exception has been created for the dungeon mobs so they will not accumulate rads. 
   *A global timer is broadcast on opening and players have 30 minutes to fight their way to level 3. 
   *On Level 3 there is a computer which players must pass a science check to open the reward room.
   *This will release the boss from the room, who must be defeated to open the locker.
   *After looting the locker, players can optionally leave through tunnel, via a grid in storage room "3"
   *The tunnel has an electrified floor, the damage can be reduced with appropriate armors or negated completely by having rubber boots in inventory. 
*/

#include "_colors.fos"
#include "_macros.fos"
#include "_maps.fos"
#include "broadcast_h.fos"
#include "mob.fos"
#include "npc_common_h.fos"
#include "npc_planes_h.fos"
#include "npc_roles_h.fos"
#include "utils_h.fos"



import bool LockerOpen(Item& item) from "lockers";
import bool LockerClose(Item& item) from "lockers";
import void SwitchState(Item& locker) from "lockers";
import void AddSpecialBonus(Item@ it) from "item_bonus";
import void ServerEventCountDownStart(string& message, int location, int time, int type)  from "broadcast";
import void InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId) from "combat";
import void AffectRadiation(Critter& cr, int value) from "radiation";





// Initialize map

void map_init(Map& map, bool firstTime)
{
    if (firstTime)
    {
        array<Item@> doors;
        for (uint i = 0, j = map.GetItemsByType(ITEM_TYPE_DOOR, doors); i < j; i++)
        {
            if (doors[i].Val6 == 0)
            {
                doors[i].Val7 = 9999999;
                doors[i].Val6 = 9999999;
            }
        }
    }
    // Radiation loop
    map.SetEvent(MAP_EVENT_LOOP_0, "_Radiate");
    map.SetLoopTime(0, 10000);
}


//Radiate all critters on map except Black Rock Soldiers
void _Radiate(Map& map)
{
    array<Critter@> crits;
    uint num = map.GetCritters(0, FIND_ALL, crits);
    
    for (uint i = 0; i < crits.length(); i++)
    {
        if (crits[i].GetProtoId() != 2019)  // Exclude PID 2019
        {
            AffectRadiation(crits[i], Random(50, 100));
        }
    }
}


//Black Rock Entrance Terminal
bool s_Terminal(Critter& player, Scenery& scanner, int skill, Item@ item)
{
	if(!player.IsPlayer())
        return false;

	if(valid(item) && item.GetProtoId() == PID_ACCESS_CARD)
	{
		Map@ map = player.GetMap();
		if(!valid(map)) return false;
		
		Item@ blastdoor = null;
		
		switch(map.GetProtoId())
		{
			case MAP_Black_Rock_Entrance :
				@blastdoor = map.GetItem(98, 81, 3999);
				break;
			default: return false;
		}
        array<uint> blastdoordata = { blastdoor.Id, map.Id };
		if(!FLAG(blastdoor.LockerCondition, LOCKER_ISOPEN))
		{
		    ServerEventCNTSet("An alarm sounds at the old Black Rock Military Base. %COUNTDOWN%", 281, 11, REAL_MINUTE(30));
		    CreateTimeEvent(AFTER(REAL_MINUTE(30)), "CloseDoor", blastdoordata, true);
			SwitchState(blastdoor);
            if(item.GetCount() > 1)
                item.SetCount(item.GetCount() - 1);
            else
                DeleteItem(item);
			FillContainers(map); 
			
		}
		
		return true;
	}
	else if(valid(item) && (item.GetProtoId() != PID_ACCESS_CARD))
	{
		if(item.GetProtoId() == PID_SECURITY_CARD)
			player.Say(SAY_NETMSG, "Unauthorised person - access denied.");
		else
			player.Say(SAY_NETMSG, "Only an authorised card will work on it.");
		
		return true;
	}
	else if(!valid(item))
	{
		if(skill == SKILL_PICK_ON_GROUND)
			player.Say(SAY_NETMSG, "There is a card slot in the machine which says \"Access\" above it."); 
		if(skill == SK_REPAIR)
			player.Say(SAY_NETMSG, "It isn't broken.");
		if(skill == SK_SCIENCE)
			player.Say(SAY_NETMSG, "You can't hack this.");
			
		return true;
	}
	
	return false;
}


//Close Black Rock Door at the end of Time Event
uint CloseDoor(array<uint>@ values)
{
	Item@ blastdoor = GetItem(values[0]);
	Map@ blackrock = GetMap(values[1]);	
	
    if(!valid(blastdoor))
        return 0;
	
	// collecting blocking critters
	array<Critter@> critters;
	
	blackrock.GetCrittersHex(98, 81, 0, FIND_LIFE_AND_KO, critters);
	
	// and now kill them all
	for(uint i = 0, j = critters.length(); i < j; i++)
	{
		if(valid(critters[i]))
		{
			critters[i].Say(SAY_NETMSG, "You were crushed by the door.");
			critters[i].ToDead(ANIM2_DEAD_EXPLODE, null);
		}
	}	
		
	if(FLAG(blastdoor.LockerCondition, LOCKER_ISOPEN))
	{
		LockerClose(blastdoor);
		
	}
	
	
	return 0;
}

//Reward Door Pin
void on_door(Item& item, bool firstTime)
{
	
	item.SetEvent(ITEM_EVENT_SKILL, "_UseBossDoor");
	
}

//Reward Door logic
bool _UseBossDoor(Item& item, Critter& player, int skill)
{
	// Opening / Closing
	player.Animate(ANIM1_UNARMED, ANIM2_USE, item, true, true);
	
    if((skill == -1) || (skill == SK_LOCKPICK))
    {	
		Map@ map = GetMap(item.MapId);
		Item@ BossDoor=map.GetItem(114, 58, 2142);
		array<uint> BossDoordata = { BossDoor.Id, map.Id };
		
		if(FLAG(BossDoor.LockerCondition, LOCKER_ISOPEN))
		{
			player.Say(SAY_NETMSG, "The door is stuck.");
		}
        else
            {
		       player.Say(SAY_NETMSG, "The door is locked, it would appear to be an electronic lock");
			}
		
        return true;
    }
	return false;
}

//Reward Door Terminal
bool s_BossDoor(Critter& player, Scenery& terminal, int skill, Item@ item)
{
    if (!player.IsPlayer() || skill != SK_SCIENCE)
    {   
        player.Say(SAY_NETMSG, "It might need a more scientific approach.");
        return true;
    }

    Map@ map = player.GetMap();
    if (!valid(map)) return false;

    Item@ BossDoor = null;

    switch (map.GetProtoId())
    {
        case MAP_Black_Rock_Level3 :
            @BossDoor = map.GetItem(114, 58, 2142); 
            break;
        default:
            return false;
    }

    array<uint> BossDoordata = { BossDoor.Id, map.Id };
    uint value = player.Skill[SK_SCIENCE] - Random(5, 15);

    if (value >= 90)
    {
        if (!FLAG(BossDoor.LockerCondition, LOCKER_ISOPEN))
        {
            CreateTimeEvent(AFTER(REAL_MINUTE(30)), "CloseDoor2", BossDoordata, true);
            SwitchState(BossDoor);
			player.Say(SAY_NETMSG, "The door opens.");
            return true;
        }
        player.Say(SAY_NETMSG, "The door is already open.");
        return true;  
    }

    player.Say(SAY_NETMSG, "You've failed to hack the security system.");
    return true;
}

//Close Reward Door at the end of Time Event
uint CloseDoor2(array<uint>@ values)
{
	Item@ BossDoor = GetItem(values[0]);
	Map@ blackrock2 = GetMap(values[1]);	
	
    if(!valid(BossDoor))
        return 0;
	
	// collecting blocking critters
	array<Critter@> critters;
	
	blackrock2.GetCrittersHex(114, 58, 0, FIND_LIFE_AND_KO, critters);
	
	// and now kill them all
	for(uint i = 0, j = critters.length(); i < j; i++)
	{
		if(valid(critters[i]))
		{
			critters[i].Say(SAY_NETMSG, "You were crushed by the door.");
			critters[i].ToDead(ANIM2_DEAD_EXPLODE, null);
		}
	}	
		
	if(FLAG(BossDoor.LockerCondition, LOCKER_ISOPEN))
	{
		LockerClose(BossDoor);
		
	}
	
	
	return 0;
}

//Add loot when Access Card is used. 
void FillContainers(Map& map)
{
    if (!valid(map))
        return;

    Location@ loc = map.GetLocation();
    array<Map@> maps;
    loc.GetMaps(maps);
    for (uint i = 0, j = maps.length(); i < j; i++)
    {
        if (valid(maps[i]))
        {
            if (maps[i].GetProtoId() == MAP_Black_Rock_Level1 ||
                maps[i].GetProtoId() == MAP_Black_Rock_Level2 ||
                maps[i].GetProtoId() == MAP_Black_Rock_Level3)
            {
                array<Item@> lockers;
                maps[i].GetItemsByType(ITEM_TYPE_CONTAINER, lockers);
                for (uint k = 0, l = lockers.length; k < l; k++)
                {
                    if (!valid(lockers[k]))
                        return;

                    ClearContainer(lockers[k]);
                    //lockers[k].LockerComplexity = Random(70, 100);
                    //lockers[k].LockerId = Random(100000000, 999999999);
                    if (FLAG(lockers[k].LockerCondition, LOCKER_ISOPEN))
                        LockerClose(lockers[k]);
                    
                    // WALL_LOCKER_RUSTY_LEFT or FRIDGE block
                    if (lockers[k].GetProtoId() == PID_WALL_LOCKER_RUSTY_LEFT || 
                        lockers[k].GetProtoId() == PID_FRIDGE)
                    {
                        uint8 num = Random(1, 8);
                        if (num == 1)
                        {
                            lockers[k].AddItem(PID_CHEMICALS, Random(5, 30), 0);
                            lockers[k].AddItem(PID_PSYCHO, Random(3, 10), 0);
                            lockers[k].AddItem(PID_SUPER_STIMPAK, Random(10, 25), 0);
                        }
                        if (num == 2)
                        {
                            lockers[k].AddItem(PID_SUPER_STIMPAK, Random(10, 25), 0);
                            lockers[k].AddItem(PID_BIO_GEL, Random(10, 25), 0);
                            lockers[k].AddItem(PID_BUFFOUT, Random(10, 25), 0);
                        }
                        if (num == 3)
                        {
                            lockers[k].AddItem(PID_BIO_GEL, Random(10, 25), 0);
                            lockers[k].AddItem(PID_MENTATS, Random(3, 10), 0);
                            lockers[k].AddItem(PID_NUKA_COLA, Random(3, 10), 0);
                        }
                        if (num == 4)
                        {
                            lockers[k].AddItem(PID_HYPODERMIC_NEEDLE, Random(5, 15), 0);
                            lockers[k].AddItem(PID_CHEMICALS, Random(5, 30), 0);
                            lockers[k].AddItem(PID_SUPER_STIMPAK, Random(10, 25), 0);
                        }
                        if (num == 5)
                        {
                            lockers[k].AddItem(PID_CHEMICALS, Random(5, 30), 0);
                            lockers[k].AddItem(PID_BUFFOUT, Random(3, 10), 0);
                            lockers[k].AddItem(PID_SUPER_STIMPAK, Random(10, 25), 0);
                        }
                        if (num == 6)
                        {
                            lockers[k].AddItem(PID_SUPER_STIMPAK, Random(10, 25), 0);
                            lockers[k].AddItem(PID_BIO_GEL, Random(10, 25), 0);
                            lockers[k].AddItem(PID_PSYCHO, Random(10, 25), 0);
                        }
                        if (num == 7)
                        {
                            lockers[k].AddItem(PID_BIO_GEL, Random(10, 25), 0);
                            lockers[k].AddItem(PID_PSYCHO, Random(3, 10), 0);
                            lockers[k].AddItem(PID_NUKA_COLA, Random(3, 10), 0);
                        }
                        if (num == 8)
                        {
                            lockers[k].AddItem(PID_HYPODERMIC_NEEDLE, Random(5, 15), 0);
                            lockers[k].AddItem(PID_BIO_GEL, Random(5, 30), 0);
                            lockers[k].AddItem(PID_NUKA_COLA, Random(10, 25), 0);
                        }
                    }

                    // LOCKER_8 block
                    if (lockers[k].GetProtoId() == PID_LOCKER_8)
                    {
                        uint8 num = Random(0, 19);
                        switch (num)
                        {
                            case 0:
                            {
                                Item@ it = lockers[k].AddItem(PID_DESERT_COMBAT_ARMOR, 1, 0);
                                Item@ it2 = lockers[k].AddItem(PID_DESERT_COMBAT_HELMET, 1, 0);
                                if (Random(1, 3) == 1) AddSpecialBonus(it);
                                if (Random(1, 3) == 1) AddSpecialBonus(it2);
                                break;
                            }
                            case 1:
                            {
                                Item@ it = lockers[k].AddItem(PID_NCR_ARMOR, 1, 0);
                                Item@ it2 = lockers[k].AddItem(PID_NCR_HELMET, 1, 0);
                                if (Random(1, 3) == 1) AddSpecialBonus(it);
                                if (Random(1, 3) == 1) AddSpecialBonus(it2);
                                break;
                            }
                            case 2: case 3: case 4: case 5: case 6: case 7:
                            {
                                Item@ it = lockers[k].AddItem(PID_COMBAT_ARMOR, 1, 0);
                                Item@ it2 = lockers[k].AddItem(PID_COMBAT_HELMET, 1, 0);
                                if (Random(1, 3) == 1) AddSpecialBonus(it);
                                if (Random(1, 3) == 1) AddSpecialBonus(it2);
                                break;
                            }
                            case 8: case 9: case 10: case 11: case 12: case 13:
                            {
                                Item@ it = lockers[k].AddItem(PID_COMBAT_ARMOR_MK_II, 1, 0);
                                Item@ it2 = lockers[k].AddItem(PID_COMBAT_HELMET_MK_II, 1, 0);
                                if (Random(1, 3) == 1) AddSpecialBonus(it);
                                if (Random(1, 3) == 1) AddSpecialBonus(it2);
                                break;
                            }
                            case 14: case 15: case 16: case 17: case 18: case 19:
                            {
                                Item@ it = lockers[k].AddItem(PID_TESLA_ARMOR, 1, 0);
                                Item@ it2 = lockers[k].AddItem(PID_TESLA_HELMET, 1, 0);
                                if (Random(1, 3) == 1) AddSpecialBonus(it);
                                if (Random(1, 3) == 1) AddSpecialBonus(it2);
                                break;
                            }
                        }
                    }

                    // LOCKER_7 block
                    if (lockers[k].GetProtoId() == PID_LOCKER_7)
                    {
                        uint8 num = Random(0, 36);
                        Item@ it = null;
                        switch (num)
                        {
                            case 0: case 1: case 2:
                                { Item@ it = lockers[k].AddItem(PID_ASSAULT_RIFLE, 1, 0); AddSpecialBonus(it); break; }
                            case 3: case 4:
                                { Item@ it = lockers[k].AddItem(PID_GRENADE_LAUNCHER, 1, 0); AddSpecialBonus(it); break; }
                            case 5: case 6:
                                { Item@ it = lockers[k].AddItem(PID_223_PISTOL, 1, 0); AddSpecialBonus(it); break; }
                            case 7: case 8:
                                { Item@ it = lockers[k].AddItem(PID_HK_P90C, 1, 0); AddSpecialBonus(it); break; }
                            case 9: case 10:
                                { Item@ it = lockers[k].AddItem(PID_PLASMA_RIFLE, 1, 0); AddSpecialBonus(it); break; }
                            case 11: case 12:
                                { Item@ it = lockers[k].AddItem(PID_AVENGER_MINIGUN, 1, 0); AddSpecialBonus(it); break; }
                            case 13: case 14:
                                { Item@ it = lockers[k].AddItem(PID_LIGHT_SUPPORT_WEAPON, 1, 0); AddSpecialBonus(it); break; }
                            case 15: case 16:
                                { Item@ it = lockers[k].AddItem(PID_SUPER_CATTLE_PROD, 1, 0); AddSpecialBonus(it); break; }
                            case 17: case 18:
                                { Item@ it = lockers[k].AddItem(PID_MEGA_POWER_FIST, 1, 0); AddSpecialBonus(it); break; }
                            case 19: case 20:
                                { Item@ it = lockers[k].AddItem(PID_SUPER_SLEDGE, 1, 0); AddSpecialBonus(it); break; }
                            case 21: case 22:
                                { Item@ it = lockers[k].AddItem(PID_HK_CAWS, 1, 0); AddSpecialBonus(it); break; }
                            case 23: case 24:
                                { Item@ it = lockers[k].AddItem(PID_IMPROVED_FLAMETHROWER, 1, 0); AddSpecialBonus(it); break; }
                            case 25: case 26:
                                { Item@ it = lockers[k].AddItem(PID_SNIPER_RIFLE, 1, 0); AddSpecialBonus(it); break; }
                            case 27: case 28:
                                { Item@ it = lockers[k].AddItem(PID_ROCKET_LAUNCHER, 1, 0); AddSpecialBonus(it); break; }
                            case 29: case 30:
                                { Item@ it = lockers[k].AddItem(PID_LASER_RIFLE_EXT_CAP, 1, 0); AddSpecialBonus(it); break; }
                            case 31: case 32:
                                { Item@ it = lockers[k].AddItem(PID_MEGA_POWER_FIST, 1, 0); AddSpecialBonus(it); break; }
                            case 33: case 34:
                                { Item@ it = lockers[k].AddItem(PID_GATLING_LASER, 1, 0); AddSpecialBonus(it); break; }
                            case 35: case 36:
                                { Item@ it = lockers[k].AddItem(PID_LASER_SMG, 1, 0); AddSpecialBonus(it); break; }
                        }
                    }

                    // FOOTLOCKER_CLEAN_LEFT block
                    if (lockers[k].GetProtoId() == PID_FOOTLOCKER_CLEAN_LEFT)
                    {
                        uint8 num = Random(0, 1);
                        switch (num)
                        {
                            case 0:
                                lockers[k].AddItem(PID_RUBBER_BOOTS, 1, 0);
                                break;
                            case 1:
                                lockers[k].AddItem(PID_BOX_OF_NOODLES, 1, 0);
                                break;
                        }
                        uint8 num2 = Random(1, 9);
                        switch (num2)
                        {
                            case 1:
                                lockers[k].AddItem(PID_FIELD_MEDIC_KIT, 1, 0);
                                break;
                            case 2:
                                lockers[k].AddItem(PID_PARAMEDICS_BAG, 1, 0);
                                break;
                            case 3:
                                lockers[k].AddItem(PID_CAR_FUEL_CELL_CONTROLLER, 1, 0);
                                break;
                            case 4:
                                lockers[k].AddItem(PID_FROZEN_DINNER, 1, 0);
                                break;
                            case 5:
                                lockers[k].AddItem(PID_MOTION_SENSOR, 1, 0);
                                break;
                            case 6:
                                lockers[k].AddItem(PID_STEALTH_BOY, 1, 0);
                                break;
                            case 7:
                                lockers[k].AddItem(PID_GUNPOWDER, 5, 20);
                                break;
                            case 8:
                                lockers[k].AddItem(PID_GUNPOWDER2, 5, 20);
                                break;
                            case 9:
                                lockers[k].AddItem(PID_ALLOYS2, 10, 20);
                                break;
                            case 10:
                                lockers[k].AddItem(PID_METAL_PARTS, 10, 20);
                                break;
                            case 11:
                                lockers[k].AddItem(PID_ALLOYS, 10, 20);
                                break;
                            case 12:
                                lockers[k].AddItem(PID_METAL_PARTS2, 10, 20);
                                break;
                        }
                    }

                    // BOOKSELF_0 or DESK_3 block
                    if (lockers[k].GetProtoId() == PID_BOOKSELF_0 || lockers[k].GetProtoId() == PID_DESK_3)
                    {
                        uint8 num = Random(1, 8);
                        if (num == 1)
                        {
                            lockers[k].AddItem(PID_BIG_BOOK_OF_SCIENCE, Random(1, 4), 0);
                            lockers[k].AddItem(PID_GUNS_AND_BULLETS, Random(1, 4), 0);
                            lockers[k].AddItem(PID_CATS_PAW_ISSUE_5, Random(1, 4), 0);
                        }
                        if (num == 2)
                        {
                            lockers[k].AddItem(PID_CHEMISTRY_MANUAL, Random(1, 4), 0);
                            lockers[k].AddItem(PID_BARTER_BOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_FIRST_AID_BOOK, Random(1, 4), 0);
                        }
                        if (num == 3)
                        {
                            lockers[k].AddItem(PID_SCOUT_HANDBOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_TECHNICAL_MANUAL, Random(1, 4), 0);
                            lockers[k].AddItem(PID_DEANS_ELECTRONICS, Random(1, 4), 0);
                        }
                        if (num == 4)
                        {
                            lockers[k].AddItem(PID_ACCOUNT_BOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_BECKY_BOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_GUNS_AND_BULLETS, Random(1, 4), 0);
                        }
                        if (num == 5)
                        {
                            lockers[k].AddItem(PID_CATS_PAW, Random(1, 4), 0);
                            lockers[k].AddItem(PID_SCOUT_HANDBOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_BIG_BOOK_OF_SCIENCE, Random(1, 4), 0);
                        }
                        if (num == 6)
                        {
                            lockers[k].AddItem(PID_BARTER_BOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_TECHNICAL_MANUAL, Random(1, 4), 0);
                            lockers[k].AddItem(PID_FIRST_AID_BOOK, Random(1, 4), 0);
                        }
                        if (num == 7)
                        {
                            lockers[k].AddItem(PID_CHEMISTRY_MANUAL, Random(1, 4), 0);
                            lockers[k].AddItem(PID_DEANS_ELECTRONICS, Random(1, 4), 0);
                            lockers[k].AddItem(PID_GUNS_AND_BULLETS, Random(1, 4), 0);
                        }
                        if (num == 8)
                        {
                            lockers[k].AddItem(PID_FIRST_AID_BOOK, Random(1, 4), 0);
                            lockers[k].AddItem(PID_BIG_BOOK_OF_SCIENCE, Random(1, 4), 0);
                            lockers[k].AddItem(PID_CATS_PAW_ISSUE_5, Random(1, 4), 0);
                        }
                    }

                    // PID_RUSTY_LOCKER_AT1 block
                    if (lockers[k].GetProtoId() == PID_RUSTY_LOCKER_AT1)
                    {
                        // Roll twice for weapons
                        for (int iWeapon = 0; iWeapon < 2; iWeapon++)
                        {
                            uint8 num = Random(0, 36);
                            Item@ it = null;
                            switch (num)
                            {
                                case 0: case 1: case 2:
                                    { Item@ it = lockers[k].AddItem(PID_ASSAULT_RIFLE, 1, 0); AddSpecialBonus(it); break; }
                                case 3: case 4:
                                    { Item@ it = lockers[k].AddItem(PID_GRENADE_LAUNCHER, 1, 0); AddSpecialBonus(it); break; }
                                case 5: case 6:
                                    { Item@ it = lockers[k].AddItem(PID_223_PISTOL, 1, 0); AddSpecialBonus(it); break; }
                                case 7: case 8:
                                    { Item@ it = lockers[k].AddItem(PID_HK_P90C, 1, 0); AddSpecialBonus(it); break; }
                                case 9: case 10:
                                    { Item@ it = lockers[k].AddItem(PID_PLASMA_RIFLE, 1, 0); AddSpecialBonus(it); break; }
                                case 11: case 12:
                                    { Item@ it = lockers[k].AddItem(PID_AVENGER_MINIGUN, 1, 0); AddSpecialBonus(it); break; }
                                case 13: case 14:
                                    { Item@ it = lockers[k].AddItem(PID_LIGHT_SUPPORT_WEAPON, 1, 0); AddSpecialBonus(it); break; }
                                case 15: case 16:
                                    { Item@ it = lockers[k].AddItem(PID_SUPER_CATTLE_PROD, 1, 0); AddSpecialBonus(it); break; }
                                case 17: case 18:
                                    { Item@ it = lockers[k].AddItem(PID_MEGA_POWER_FIST, 1, 0); AddSpecialBonus(it); break; }
                                case 19: case 20:
                                    { Item@ it = lockers[k].AddItem(PID_SUPER_SLEDGE, 1, 0); AddSpecialBonus(it); break; }
                                case 21: case 22:
                                    { Item@ it = lockers[k].AddItem(PID_HK_CAWS, 1, 0); AddSpecialBonus(it); break; }
                                case 23: case 24:
                                    { Item@ it = lockers[k].AddItem(PID_IMPROVED_FLAMETHROWER, 1, 0); AddSpecialBonus(it); break; }
                                case 25: case 26:
                                    { Item@ it = lockers[k].AddItem(PID_SNIPER_RIFLE, 1, 0); AddSpecialBonus(it); break; }
                                case 27: case 28:
                                    { Item@ it = lockers[k].AddItem(PID_ROCKET_LAUNCHER, 1, 0); AddSpecialBonus(it); break; }
                                case 29: case 30:
                                    { Item@ it = lockers[k].AddItem(PID_LASER_RIFLE_EXT_CAP, 1, 0); AddSpecialBonus(it); break; }
                                case 31: case 32:
                                    { Item@ it = lockers[k].AddItem(PID_LASER_SUPPORT_WEAPON, 1, 0); AddSpecialBonus(it); break; }
                                case 33: case 34:
                                    { Item@ it = lockers[k].AddItem(PID_GATLING_LASER, 1, 0); AddSpecialBonus(it); break; }
                                case 35: case 36:
                                    { Item@ it = lockers[k].AddItem(PID_LASER_SMG, 1, 0); AddSpecialBonus(it); break; }
                            }
                        }

                        // Roll twice for armor
                        for (int iArmor = 0; iArmor < 2; iArmor++)
                        {
                            uint8 num = Random(0, 19);
                            Item@ it = null;
                            Item@ it2 = null;
                            switch (num)
                            {
                                case 0:
                                    { Item@ it = lockers[k].AddItem(PID_DESERT_COMBAT_ARMOR, 1, 0);
                                      Item@ it2 = lockers[k].AddItem(PID_DESERT_COMBAT_HELMET, 1, 0);
                                      AddSpecialBonus(it);
                                      AddSpecialBonus(it2); break; }
                                case 1:
                                    { Item@ it = lockers[k].AddItem(PID_NCR_ARMOR, 1, 0);
                                      Item@ it2 = lockers[k].AddItem(PID_NCR_HELMET, 1, 0);
                                      AddSpecialBonus(it);
                                      AddSpecialBonus(it2); break; }
                                case 2: case 3: case 4: case 5: case 6: case 7:
                                    {
                                      lockers[k].AddItem(PID_ENCLAVE_COMBAT_ARMOR, 1, 0);
                                      lockers[k].AddItem(PID_ENCLAVE_COMBAT_HELMET, 1, 0);
                                      break;
                                    }
                                case 8: case 9: case 10: case 11: case 12: case 13: case 14:
                                    { Item@ it = lockers[k].AddItem(PID_COMBAT_ARMOR_MK_II, 1, 0);
                                      Item@ it2 = lockers[k].AddItem(PID_COMBAT_HELMET_MK_II, 1, 0);
                                      AddSpecialBonus(it);
                                      AddSpecialBonus(it2); break; }
                                case 15: case 16: case 17:
                                    { Item@ it = lockers[k].AddItem(PID_KEEPBRIGE_ROBE, 1, 0); AddSpecialBonus(it); break; }
                                case 18: case 19:
                                    {
                                      lockers[k].AddItem(PID_BROTHERHOOD_COMBAT_ARMOR, 1, 0);
                                      lockers[k].AddItem(PID_BROTHERHOOD_HELMET, 1, 0);
                                      break;
                                    }
                            }
                        }
                        
                        // Roll for implants
                        uint8 num = Random(0, 40);
                        switch (num)
                        {
                            case 0: case 1: case 2:
                                lockers[k].AddItem(PID_IMPLANT_LUCK, 1, 0); break;
                            case 3: case 4: case 5:
                                lockers[k].AddItem(PID_IMPLANT_STRENGTH, 1, 0); break;
                            case 6: case 7: case 8:
                                lockers[k].AddItem(PID_PK12_GAUSS_PISTOL, 1, 0); break;
                            case 9: case 10: case 11:
                                lockers[k].AddItem(PID_IMPLANT_PERCEPTION, 1, 0); break;
                            case 12: case 13: case 14:
                                lockers[k].AddItem(PID_IMPLANT_ENDURANCE, 1, 0); break;
                            case 15: case 16: case 17:
                                lockers[k].AddItem(PID_HK_G11E, 1, 0); break;
                            case 18: case 19: case 20:
                                lockers[k].AddItem(PID_TURBO_PLASMA_RIFLE, 1, 0); break;
                            case 21: case 22: case 23:
                                lockers[k].AddItem(PID_INDEPENDENT, 1, 0); break;
                            case 24: case 25: case 26:
                                lockers[k].AddItem(PID_PANCOR_JACKHAMMER, 1, 0); break;
                            case 27: case 28: case 29:
                                lockers[k].AddItem(PID_POWERED_ARMOR, 1, 0);
                                lockers[k].AddItem(PID_POWER_HELMET, 1, 0); break;
                            case 30: case 31: case 32:
                                lockers[k].AddItem(PID_IMPLANT_CHARISMA, 1, 0); break;
                            case 33: case 34: case 35:
                                lockers[k].AddItem(PID_IMPLANT_INTELLIGENCE, 1, 0); break;
                            case 36: case 37: case 38:
                                lockers[k].AddItem(PID_IMPLANT_AGILITY, 1, 0); break;
                            case 39:
                                lockers[k].AddItem(PID_BOZAR, 1, 0); break;
                            case 40:
                                lockers[k].AddItem(PID_HARDENED_POWER_ARMOR, 1, 0);
                                lockers[k].AddItem(PID_HARDENED_POWER_HELMET, 1, 0); break;
                        }

                        uint8 dollarNum = Random(0, 0);
                        switch (dollarNum)
                        {
                            case 0:
                                lockers[k].AddItem(PID_DOLLAR2, Random(500, 1200), 0); break;
                        }

                        uint8 ammoNum = Random(0, 2);
                        switch (ammoNum)
                        {
                            case 0:
                                lockers[k].AddItem(PID_SHOTGUN_DRAGON_BREATH_SHELLS, Random(10, 25), 0); break;
                            case 1:
                                lockers[k].AddItem(PID_2MM_EC_AMMO, Random(5, 15), 0); break;
                            case 2:
                                lockers[k].AddItem(PID_4_7MM_CASELESS, Random(150, 400), 0); break;
                        }
                    } 
                } 
            } 
        } 
    } 
    return;
}




bool IsRubberBoots(Critter& cr)
{
    return valid(cr.GetItem(PID_RUBBER_BOOTS, -1));
}


void ElectrifyVents(Critter& cr, Scenery& trigger, bool entered, uint8 Dir) 
{
    if (entered && !IsRubberBoots(cr)) 
    {
        if (cr.IsLife())
        {
           
            InjureCritter(cr, Random(80, 100), DAMAGE_ELECTR, cr.Dir, 0);
            
           
            Map@ map = cr.GetMap();
            
           
            uint16 stepX = cr.HexX;
            uint16 stepY = cr.HexY;
            
           
            uint8 radius = 3; // Adjust as needed.
            
          
            map.MoveHexByDir(stepX, stepY, 4, radius);
            
           
            for (uint8 stepDir = 0; stepDir < 6; stepDir++)
            {
                
                for (uint step = 0; step < radius; step++)
                {
                   
                    map.MoveHexByDir(stepX, stepY, stepDir, 1);
                    
                   
                    map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                }
            }
        }
    }
}


void _BlackRock(Critter& mob, bool firstTime)
{    
    critter_init(mob, firstTime); 
	mob.StatBase[ST_NPC_ROLE] = 1;  
    mob.StatBase[ST_DIALOG_ID] = 23379; 
	mob.StatBase[ST_TEAM_ID] = 5001; 
    mob.StatBase[ST_MAX_LIFE] = 300;  
    mob.StatBase[ST_CURRENT_HP] = 315; 
    mob.StatBase[ST_KILL_EXPERIENCE] = 1500; 
    mob.StatBase[ST_REPLICATION_TIME] = 1800;
    mob.PerkBase[PE_BONUS_RANGED_DAMAGE] = 1;
    mob.ModeBase[MODE_NO_HOME] = 0;
    mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;

    
	array<int> bagIds = {162, 165, 168, 173, 177, 178, 181, 185, 192, 195, 196, 197, 200, 201, 242 };

 
    int randomIndex = Random(0, bagIds.length() - 1);
    mob.StatBase[ST_BAG_ID] = bagIds[randomIndex];
	
}

void _BlackRockBoss(Critter& mob, bool firstTime)
{    
    critter_init_aggr(mob, firstTime); 
	mob.StatBase[ST_BAG_ID] = 176; 
	mob.StatBase[ST_NPC_ROLE] = 1;  
    mob.StatBase[ST_DIALOG_ID] = 24000; 
	mob.StatBase[ST_TEAM_ID] = 5001; 
    mob.StatBase[ST_MAX_LIFE] = 2000;  
    mob.StatBase[ST_CURRENT_HP] = 2015; 
    mob.StatBase[ST_KILL_EXPERIENCE] = 10000; 
    mob.StatBase[ST_REPLICATION_TIME] = 900; //Deliberately less than normal mobs to give him time to respawn and re-enter the reward room before the door closes. 
    mob.PerkBase[PE_BONUS_RANGED_DAMAGE] = 2;
	mob.PerkBase[PE_MORE_RANGED_DAMAGE] = 1;
	mob.PerkBase[PE_LIVING_ANATOMY] = 1;
    mob.ModeBase[MODE_NO_HOME] = 0;
    mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;

    
	
}

void RewardLocker(Item& item, bool firstTime)
{
	item.SetEvent(ITEM_EVENT_SKILL, "_UseRewardLocker");		
	
}

bool _UseRewardLocker(Item& item, Critter& crit, int skill)
{
	// Opening / Closing
    if((skill == -1) || (skill == SK_STEAL))
    {
		if(!isMobsKilled(crit))
        {
			uint16 hexX = 0;
			uint16 hexY = 0;
			Map@   map = item.GetMapPosition(hexX, hexY);
			map.SetText(hexX, hexY, COLOR_WHITE,  "Too dangerous right now to worry about that.");		
            return true;
        }
		
        // open it if closed
        if(_LockerIsClose(item))
        {
			//item.LockerId = 0;
			//item.LockerId = Random(98989, 989898);
			//item.LockerComplexity = Random(50,50);			
            return false;
        }
    }
    return false;
}



bool isMobsKilled(Critter& player)
{     											
	uint numLifeMobs = player.GetMap().GetNpcCount(1, FIND_ONLY_NPC | FIND_LIFE); 			 
																							 
	if(numLifeMobs!=0)
	{
		for(uint i = 0; i < numLifeMobs; i++)
		{
			Critter@ mob = player.GetMap().GetNpc(1, FIND_ONLY_NPC | FIND_LIFE, i);
			switch (Random(1,3))
			{
				case 1: {mob.Say(SAY_SHOUT_ON_HEAD, "Not on my watch!"); break;}
				case 2: {mob.Say(SAY_SHOUT_ON_HEAD, "That`s a world of pain!"); break;}
				case 3: {mob.Say(SAY_SHOUT_ON_HEAD, "Stand down, now!"); break;}				
			}
			
		}	
		return false;
	}
	else
		return true;

}











