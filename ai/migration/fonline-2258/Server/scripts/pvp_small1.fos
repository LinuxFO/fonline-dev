#include "_colors.fos"
#include "broadcast_h.fos"
#include "entire.fos"
#include "logging_h.fos"
#include "mob.fos"
#include "npc_planes_h.fos"
#include "quest_killmobs_h.fos"
#include "utils_h.fos"
#include "worldmap_h.fos"




 
#define QUEST_ALL_KILLED            (0)  //value of quest lvar in case all enemies are killed
#define QUEST_FAILED                (0)  //value of quest lvar in case of quest failed
 
#define DIALOG                      (23377) //dialog id of npc spawned in location - all_clowns
 
array<uint16> ClownPids = { 2016, 2017, 2018 }; 
 

void r_SpawnLoc(Critter& player, Critter@ npc)
{
    array<array<uint>> spawnCoords = {
        {1170, 974}, 
        {1326, 988},  
        {1476, 1066}, 
        {1522, 1172}, 
        {1718, 982}, 
        {1968, 918}   
    };

  
    uint index = Random(0, spawnCoords.length() - 1);
    uint wx = spawnCoords[index][0]; // X coordinate
    uint wy = spawnCoords[index][1]; // Y coordinate

    
    array<uint16> locationIds = { 234 };
    uint num = locationIds.length;
 
  
    uint16        locPid = locationIds[Random(0, num - 1)];
   
    //create quest location
    Critter@[] crits = { player };
    int           loc = CreateLocation(locPid, wx, wy, crits);
    if(loc == 0)
        return;
    player.SetKnownLoc(true, loc);
   
    //set location id to quest lvar (used when you need to delete location)
    GameVar@  locidv = GetLocalVar(LVAR_x_pvpsmall1_locid, player.Id);
    locidv = loc;
   
    //change location color on WM
    Location@ location = GetLocation(loc);
    location.Color = COLOR_TEAL;
    location.Update();
 
    //player can die and come back
    location.AutoGarbage = false;
 
    //dissable default encounter's script and functions
    array<Map@> maps;
    uint        mapcount = location.GetMaps(maps);
    for(uint c = 0; c < mapcount; c++)
    {
        maps[c].SetScript(null);
        maps[c].SetEvent(MAP_EVENT_IN_CRITTER, null);
        maps[c].SetEvent(MAP_EVENT_CRITTER_DEAD, null);
    }
 
    //set player as owner of the map
    Map@ map = GetLocation(loc).GetMapByIndex(0);
    SetOwnerId(map, player.Id);
	ServerEventCNTSet("Somewhere between New Reno and Las Vegas a caravan has broken down... %COUNTDOWN%", 234, 11, REAL_MINUTE(16));
 
    //spawn enemies
    bool spawned = false;
    while(!spawned)
    {
        //get map spawn points
        array<Entire> entires;
        ParseEntires(map, entires, 666);
       
        //pick random entire
        Entire@       ent = random_from_array(entires);
        uint16        hx = ent.HexX;
        uint16        hy = ent.HexY;
        map.GetHexCoord(ent.HexX, ent.HexY, hx, hy, Random(0, 359), Random(3, 7));
 
      
        for(uint i = 0, j = Random(12, 12); i < j; i++)
        {
            uint8 dir = Random(0, 5);
            uint step = Random(1, 2);
            map.MoveHexByDir(hx, hy, dir, step);
            uint16 npcPid = ClownPids[Random(0, ClownPids.length()-1)];
            int[] params =
            {
                ST_TEAM_ID, 5001,
               //ST_BAG_ID, 575,
                ST_KILL_EXPERIENCE, 1000,
                ST_REPLICATION_TIME, REPLICATION_NEVER,
                ST_LEVEL, 12,
                ST_DIALOG_ID, DIALOG
            };
 
            Critter@ Clown = map.AddNpc(npcPid , hx, hy, Random(0, 5), params, null, "pvp_small1@_ClownInit");
            if(valid(Clown))
            {
                spawned = true;
            }
        }
    }
 
    //16 Mins
    SetQuestGarbager(1 * 16, player.Id, loc, LVAR_x_pvpsmall1_trigger, QUEST_FAILED);
    DynamicLocationAddLog(player, npc, locidv, "pvp_small1");
}
 
//dialog function used in request to delete quest location (after player report finishing the quest)
void r_DeleteLoc(Critter& player, Critter@ npc)
{
    GameVar@ var = GetLocalVar(LVAR_x_pvpsmall1_locid, player.Id);
    DeleteLocation(var.GetValue());
    DynamicLocationDelLog(player, npc, var, "pvp_small1");
}
 
//set functions for basic critter events
void _ClownInit(Critter& mob, bool firstTime)
{
    //critter_init(mob, firstTime); 
	mob.StatBase[ST_MAX_LIFE] = 250;  
    mob.StatBase[ST_CURRENT_HP] = 265; 
	mob.StatBase[ST_NPC_ROLE] = 1;  
    mob.StatBase[ST_REPLICATION_TIME] = REPLICATION_DELETE;
    mob.SetEvent(CRITTER_EVENT_DEAD, "_ClownDead");
	mob.ModeBase[MODE_NO_HOME] = 1; 
	mob.ModeBase[MODE_NO_LOOT] = 1; 
    mob.ModeBase[MODE_NO_DROP] = 1;
    mob.ModeBase[MODE_NO_STEAL] = 1;
    mob.ModeBase[MODE_NO_BARTER] = 1;
    mob.ModeBase[MODE_UNLIMITED_AMMO] = 1;
	mob.SetEvent(CRITTER_EVENT_IDLE, "_NpcScout");
	
	 array<int> bagIds = {162, 165, 168, 173, 176, 177, 178, 181, 185, 192, 195, 196, 197, 200, 201};
     int randomIndex = Random(0, bagIds.length() - 1);
     mob.StatBase[ST_BAG_ID] = bagIds[randomIndex];
 
    _CritSetExtMode(mob, MODE_EXT_MOB);
}
 

void _ClownDead(Critter& mob, Critter@ killer)
{
    Map@ map = mob.GetMap();
    if(MobsDead(map, ClownPids))
    {
        GameVar@ var = GetLocalVar(LVAR_x_pvpsmall1, GetOwnerId(map));
        
		var = QUEST_ALL_KILLED;
    }
}

void _NpcScout(Critter& npc)
{
    // the great optimizer
    if(!npc.IsLife())
    {
        npc.Wait(IDLE_NORMAL);
        return;
    }

    // check critters in sight
    array<Critter@> crits;
    // get visible players
    uint            num = npc.GetCritters(false, FIND_ONLY_PLAYERS | FIND_LIFE, crits);

    
    // check distance
    uint dist = GetDistance(npc);
    for(uint i = 0; i < num; i++)
    {
        if(GetCrittersDistantion(npc, crits[i]) > dist)
            continue;
        else
        {
            // attack
            npc.AddEnemyInStack(crits[i].Id);
            return;
        }
    }
    if(crits.length() > 0)
    {
       
        npc.Wait(IDLE_ALERTED);
    }
    else
    {
        if(Random(0, 0) == 0)
        MoveRandom(npc, 12);
         // till next move
         npc.Wait(Random(500, 2000));
       
    }
}